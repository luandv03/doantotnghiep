# -*- coding: utf-8 -*-
"""Phân bổ nguồn lực - Greedy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fZ7Q5wI6JwKYh1FNDTzcLTbJvRf8mp7R

**BƯỚC 1: UPLOAD và ĐỌC DỮ LIỆU**
"""

from google.colab import files
import json
import time

uploaded = files.upload()

def get_filename(pattern):
    for fname in uploaded.keys():
        if pattern in fname:
            return fname
    raise ValueError(f"Không tìm thấy file phù hợp với pattern: {pattern}")

input_file = get_filename('input')
schedule_file = get_filename('schedule')

with open(input_file, encoding='utf-8') as f:
    data = json.load(f)
with open(schedule_file, encoding='utf-8') as f:
    schedules = json.load(f)


# Khai báo các biến dữ liệu
production_orders = data['productionOrders']  # Danh sách lệnh sản xuất
operations = data['operations']               # Danh sách công đoạn
assets = data['assets']                       # Danh sách thiết bị/máy móc
workers = data['workers']                     # Danh sách nhân viên

# Tạo dict tiện tra cứu nhanh
assets_dict = {a['id']: a for a in assets}
workers_dict = {w['id']: w for w in workers}

"""# Mục mới

**BƯỚC 2: HÀM TIỆN ÍCH**
"""

def is_consecutive(assignments, date_idx, shift_idx):
    """
    Kiểm tra nhân viên đã bị phân lịch vào ca liên tiếp chưa (không cho phép 2 ca liên tiếp).
    """
    if shift_idx > 0 and (date_idx, shift_idx-1) in assignments:
        return True
    if shift_idx < 3 and (date_idx, shift_idx+1) in assignments:
        return True
    if shift_idx == 0 and (date_idx-1, 3) in assignments:
        return True
    if shift_idx == 3 and (date_idx+1, 0) in assignments:
        return True
    return False

def calc_kpi(worker, asset, hours):
    """
    Tính toán năng suất (ns) và chất lượng (cl) dựa vào worker, máy, số giờ làm việc.
    """
    ns = worker['productivityKPI'] * asset['productivity'] * hours
    cl = ns * worker['qualityKPI']
    return ns, cl

def calc_cost(worker, asset, hours):
    """
    Tính chi phí cho một ca làm việc: (lương nhân viên/giờ + chi phí máy/giờ) * số giờ.
    """
    return (worker.get('salaryPerHour', 0) + asset.get('costPerHour', 0)) * hours

"""**BƯỚC 3: LẬP LỊCH GREEDY (chọn tốt nhất, break ngay khi đủ KPI)**"""

worker_assignments = {}   # Lưu lại ca đã phân cho từng nhân viên
machine_assignments = {}  # Lưu lại ca đã phân cho từng máy
operation_progress = {}   # Lưu tiến độ từng công đoạn: kpi, lịch sử, trạng thái, chi phí
op_status = {}            # op_id -> True/False: đã hoàn thành chưa
op_end_time = {}          # op_id -> (date_idx, shift_idx): ca hoàn thành cuối cùng

start_time = time.time()  # Đo thời gian thực thi thuật toán

pending_ops = operations.copy()  # Danh sách công đoạn chưa lập lịch xong

while pending_ops:
    next_pending = []
    for op in pending_ops:
        op_id = op['id']
        prev_ops = op.get('prevOperation', [])
        # Nếu còn công đoạn tiên quyết chưa xong thì bỏ qua lần này
        if prev_ops and not all(op_status.get(pid, False) for pid in prev_ops):
            next_pending.append(op)
            continue

        # Xác định thời điểm bắt đầu sớm nhất
        if prev_ops:
            prev_end_times = [op_end_time[pid] for pid in prev_ops]
            latest_end = max(prev_end_times)
            prev_date, prev_shift = latest_end
            max_shift_idx = schedules[0]['shift_count'] - 1
            if prev_shift < max_shift_idx:
                earliest_start = (prev_date, prev_shift + 1)
            else:
                earliest_start = (prev_date + 1, 0)
        else:
            earliest_start = (0, 0)  # Nếu là công đoạn đầu thì bắt đầu từ ngày đầu

        # Chuẩn bị các biến tích lũy
        kpi_targets = {k['id']: k['value'] for k in op['kpis']}  # Giá trị mục tiêu KPI
        kpi_accum = {k['id']: 0 for k in op['kpis']}             # Giá trị đạt được thực tế
        op_history = []  # Lịch sử các lần phân bổ cho công đoạn này
        op_cost = 0
        done = False
        last_used = (0, 0)

        # ====== Lập lịch greedy từng ngày, từng ca ======
        break_outer = False  # Dùng để break cả 2 vòng lặp khi đã đạt KPI
        for date_idx, sch in enumerate(schedules):
            if break_outer:
                break
            for shift_idx in range(sch['shift_count']):
                if (date_idx, shift_idx) < earliest_start:
                    continue

                # ==== Check KPI trước khi phân bổ: Nếu đủ rồi thì dừng luôn ====
                if all(kpi_accum[kid] >= kpi_targets[kid] for kid in kpi_targets):
                    done = True
                    break_outer = True
                    break

                # ==== Lấy nhân viên hợp lệ cho ca này ====
                valid_workers = []
                for wid, slots in sch['schedule'].items():
                    if slots[shift_idx] == 1:
                        w = workers_dict.get(wid)
                        if not w or w['position'] != op['requiredPosition']:
                            continue
                        assignments = worker_assignments.get(wid, set())
                        if is_consecutive(assignments, date_idx, shift_idx):
                            continue
                        if (date_idx, shift_idx) in assignments:
                            continue
                        valid_workers.append((wid, w))
                # Ưu tiên nhân viên mạnh nhất
                valid_workers.sort(key=lambda x: x[1]['productivityKPI'] * x[1]['qualityKPI'], reverse=True)

                # ==== Lấy máy hợp lệ cho ca này ====
                valid_machines = []
                for aid, a in assets_dict.items():
                    if a['machineType'] != op['requiredMachineType']:
                        continue
                    assignments = machine_assignments.get(aid, set())
                    if (date_idx, shift_idx) in assignments:
                        continue
                    valid_machines.append((aid, a))
                # Ưu tiên máy mạnh nhất
                valid_machines.sort(key=lambda x: x[1]['productivity'], reverse=True)

                # ==== Ghép từng cặp nhân viên - máy ====
                num_pairs = min(len(valid_workers), len(valid_machines))
                used_workers = set()
                used_machines = set()
                for i in range(num_pairs):
                    # === Kiểm tra lại KPI, nếu đủ thì dừng ngay vòng nhỏ nhất ===
                    if all(kpi_accum[kid] >= kpi_targets[kid] for kid in kpi_targets):
                        done = True
                        break_outer = True
                        break

                    wid, w = valid_workers[i]
                    aid, a = valid_machines[i]
                    if wid in used_workers or aid in used_machines:
                        continue
                    hours = sch['work_duration_per_shift']
                    ns, cl = calc_kpi(w, a, hours)
                    cost = calc_cost(w, a, hours)

                    # Chỉ cộng KPI nếu chỉ tiêu đó chưa đạt (tránh cộng quá lố)
                    for k_idx, kpi in enumerate(op['kpis']):
                        if k_idx == 0:
                            kpi_accum[kpi['id']] += ns
                        else:
                            kpi_accum[kpi['id']] += cl

                    # Ghi lịch sử và cập nhật chi phí
                    op_history.append({
                        'date': sch['date'], 'shift': shift_idx+1,
                        'worker_id': wid, 'worker_name': w['name'],
                        'machine_id': aid, 'machine_name': a['name'],
                        'ns': ns, 'cl': cl,
                        'cost': cost
                    })
                    op_cost += cost
                    # Đánh dấu đã phân công ca này
                    worker_assignments.setdefault(wid, set()).add((date_idx, shift_idx))
                    machine_assignments.setdefault(aid, set()).add((date_idx, shift_idx))
                    used_workers.add(wid)
                    used_machines.add(aid)
                    last_used = (date_idx, shift_idx)
                # Sau mỗi ca cũng kiểm tra lại KPI (đủ là dừng luôn)
                if all(kpi_accum[kid] >= kpi_targets[kid] for kid in kpi_targets):
                    done = True
                    break_outer = True
                    break

        # Lưu kết quả cho công đoạn
        operation_progress[op_id] = {
            'kpi': kpi_accum, 'done': done, 'history': op_history, 'cost': op_cost
        }
        op_status[op_id] = done
        op_end_time[op_id] = last_used

    # Nếu không lập lịch được thêm công đoạn nào, báo lỗi phụ thuộc hoặc thiếu nguồn lực
    if len(next_pending) == len(pending_ops):
        print("\n⚠️ Có công đoạn không thể lập lịch do phụ thuộc lẫn nhau hoặc không đủ nguồn lực!")
        print("Các công đoạn còn pending:", [op['id'] for op in next_pending])
        break
    pending_ops = next_pending

end_time = time.time()  # Đo thời gian kết thúc

"""**BƯỚC 4: IN KẾT QUẢ PHÂN BỔ & TỔNG HỢP**"""

num_done = 0
total_cost = 0
all_working_slots = set()  # (ngày, ca)
opid_to_orderid = {op['id']: op['productionOrderId'] for op in operations}
orderid_to_ops = {}
for op in operations:
    orderid_to_ops.setdefault(op['productionOrderId'], []).append(op['id'])

for op_id, result in operation_progress.items():
    status = 'HOÀN THÀNH' if result['done'] else 'CHƯA HOÀN THÀNH'
    print(f"\n== Công đoạn {op_id}: {status} ==")
    for entry in result['history']:
        print(f"  Ngày {entry['date']} - Ca {entry['shift']}: "
              f"{entry['worker_id']} ({entry['worker_name']}) + "
              f"{entry['machine_id']} ({entry['machine_name']}) | "
              f"Năng suất: {entry['ns']:.2f}, Chất lượng: {entry['cl']:.2f}, "
              f"Chi phí: {entry['cost']:.0f}")
        all_working_slots.add((entry['date'], entry['shift']))
    print("Tổng KPI:", result['kpi'])
    print(f"Tổng chi phí công đoạn: {result['cost']:.0f}")
    if result['done']:
        num_done += 1
        total_cost += result['cost']

# Đếm số lệnh sản xuất hoàn thành
order_done = 0
for order in production_orders:
    order_id = order['id']
    ops = orderid_to_ops.get(order_id, [])
    if all(operation_progress.get(opid, {}).get('done', False) for opid in ops):
        order_done += 1

# Đếm tổng số ca sử dụng (không trùng lặp)
total_shifts = len(all_working_slots)
print(f"\n>> Tổng số lệnh sản xuất hoàn thành: {order_done}/{len(production_orders)}")
print(f">> Tổng số ca sử dụng: {total_shifts}")
print(f">> Tổng chi phí sản xuất: {total_cost:.0f}")
print(f">> Thời gian thực thi thuật toán: {end_time - start_time:.4f} giây")